---
title: Connect Azure Functions to Azure Storage using Visual Studio Code
description: Learn how to connect Azure Functions to an Azure Queue Storage by adding an output binding to your Visual Studio Code project.
ms.date: 01/31/2023
ms.topic: quickstart
ms.devlang: csharp, java, javascript, powershell, python, typescript
ms.custom: devx-track-python, devx-track-js, mode-ui, devdivchpfy22, devx-track-extended-java
zone_pivot_groups: programming-languages-set-functions
#Customer intent: As an Azure Functions developer, I want to connect my function to Azure Storage so that I can easily write data to a storage queue.
---

# Connect Azure Functions to Azure Storage using Visual Studio Code

[!INCLUDE [functions-add-storage-binding-intro](../../includes/functions-add-storage-binding-intro.md)]

In this article, you learn how to use Visual Studio Code to connect Azure Storage to the function you created in the previous quickstart article. The output binding that you add to this function writes data from the HTTP request to a message in an Azure Queue storage queue.

Most bindings require a stored connection string that Functions uses to access the bound service. To make it easier, you use the storage account that you created with your function app. The connection to this account is already stored in an app setting named `AzureWebJobsStorage`.  

## Configure your local environment

Before you begin, you must meet the following requirements:

* Install the [Azure Storage extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestorage).

* Install [Azure Storage Explorer](https://storageexplorer.com/). Storage Explorer is a tool that you'll use to examine queue messages generated by your output binding. Storage Explorer is supported on macOS, Windows, and Linux-based operating systems.

::: zone pivot="programming-language-csharp"

* Install [.NET Core CLI tools](/dotnet/core/tools/?tabs=netcore2x).
::: zone-end

::: zone pivot="programming-language-csharp"

* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-csharp.md).
::: zone-end  
::: zone pivot="programming-language-javascript"  
* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-node.md).
::: zone-end
::: zone pivot="programming-language-java"  
* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-java.md).
::: zone-end
::: zone pivot="programming-language-typescript"  
* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-typescript.md).
::: zone-end
::: zone pivot="programming-language-python"  
* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-python.md).
::: zone-end
::: zone pivot="programming-language-powershell"  
* Complete the steps in [part 1 of the Visual Studio Code quickstart](create-first-function-vs-code-powershell.md).
::: zone-end

This article assumes that you're already signed in to your Azure subscription from Visual Studio Code. You can sign in by running `Azure: Sign In` from the command palette.

## Download the function app settings

In the [previous quickstart article](./create-first-function-vs-code-csharp.md), you created a function app in Azure along with the required storage account. The connection string for this account is stored securely in the app settings in Azure. In this article, you write messages to a Storage queue in the same account. To connect to your storage account when running the function locally, you must download app settings to the *local.settings.json* file.

1. Press <kbd>F1</kbd> to open the command palette, then search for and run the command `Azure Functions: Download Remote Settings...`.

1. Choose the function app you created in the previous article. Select **Yes to all** to overwrite the existing local settings.

    > [!IMPORTANT]  
    > Because the *local.settings.json* file contains secrets, it never gets published, and is excluded from the source control.

1. Copy the value `AzureWebJobsStorage`, which is the key for the storage account connection string value. You use this connection to verify that the output binding works as expected.

## Register binding extensions

Because you're using a Queue storage output binding, you must have the Storage bindings extension installed before you run the project.

::: zone pivot="programming-language-javascript,programming-language-typescript,programming-language-python,programming-language-powershell,programming-language-java"

Your project has been configured to use [extension bundles](functions-bindings-register.md#extension-bundles), which automatically installs a predefined set of extension packages.

Extension bundles is already enabled in the *host.json* file at the root of the project, which should look like the following example:

:::code language="json" source="~/functions-docs-python/functions-add-output-binding-storage-queue-cli/host.json":::

Now, you can add the storage output binding to your project.

::: zone-end

::: zone pivot="programming-language-csharp"

[!INCLUDE [functions-register-storage-binding-extension-csharp](../../includes/functions-register-storage-binding-extension-csharp.md)]

::: zone-end

## Add an output binding


::: zone pivot="programming-language-javascript,programming-language-typescript,programming-language-powershell"

In Functions, each type of binding requires a `direction`, `type`, and unique `name`. The way you define these attributes depends on the language of your function app.

[!INCLUDE [functions-add-output-binding-json](../../includes/functions-add-output-binding-json.md)]

::: zone-end

::: zone pivot="programming-language-python"
In Functions, each type of binding requires a `direction`, `type`, and a unique `name`. The way you define these attributes depends on your Python programming model.

[!INCLUDE [functions-add-storage-binding-python](../../includes/functions-add-storage-binding-python.md)]

::: zone-end

::: zone pivot="programming-language-csharp"

[!INCLUDE [functions-add-storage-binding-csharp-library](../../includes/functions-add-storage-binding-csharp-library.md)]

::: zone-end

::: zone pivot="programming-language-java"

[!INCLUDE [functions-add-output-binding-java](../../includes/functions-add-output-binding-java.md)]

::: zone-end

## Add code that uses the output binding

After the binding is defined, you can use the `name` of the binding to access it as an attribute in the function signature. By using an output binding, you don't have to use the Azure Storage SDK code for authentication, getting a queue reference, or writing data. The Functions runtime and queue output binding do those tasks for you.

::: zone pivot="programming-language-javascript"  
[!INCLUDE [functions-add-output-binding-js](../../includes/functions-add-output-binding-js.md)]
::: zone-end  

::: zone pivot="programming-language-typescript"  
[!INCLUDE [functions-add-output-binding-ts](../../includes/functions-add-output-binding-ts.md)]
::: zone-end  

::: zone pivot="programming-language-powershell"

[!INCLUDE [functions-add-output-binding-powershell](../../includes/functions-add-output-binding-powershell.md)]

::: zone-end

::: zone pivot="programming-language-python"

[!INCLUDE [functions-add-output-binding-python](../../includes/functions-add-output-binding-python-v1-v2.md)]

::: zone-end

::: zone pivot="programming-language-csharp"  

[!INCLUDE [functions-add-storage-binding-csharp-library-code](../../includes/functions-add-storage-binding-csharp-library-code.md)]

::: zone-end  

::: zone pivot="programming-language-java"  

[!INCLUDE [functions-add-storage-binding-java-code](../../includes/functions-add-storage-binding-java-code.md)]

## Update the tests

[!INCLUDE [functions-add-output-binding-java-test](../../includes/functions-add-output-binding-java-test.md)]

::: zone-end  

::: zone pivot="programming-language-csharp"  

[!INCLUDE [functions-run-function-test-local-vs-code-csharp](../../includes/functions-run-function-test-local-vs-code-csharp.md)]

::: zone-end  
::: zone pivot="programming-language-javascript,programming-language-typescript,programming-language-python,programming-language-powershell,programming-language-java"

## Run the function locally

1. As in the previous article, press <kbd>F5</kbd> to start the function app project and Core Tools.

1. With the Core Tools running, go to the **Azure: Functions** area. Under **Functions**, expand **Local Project** > **Functions**. Right-click (Ctrl-click on Mac) the `HttpExample` function and select **Execute Function Now...**.

    :::image type="content" source="../../includes/media/functions-run-function-test-local-vs-code/execute-function-now.png" alt-text="Screenshot of executing function from Visual Studio Code.":::

1. In the **Enter request body**, you see the request message body value of `{ "name": "Azure" }`. Press <kbd>Enter</kbd> to send this request message to your function.  

1. After a response is returned, press <kbd>Ctrl + C</kbd> to stop Core Tools.

Because you're using the storage connection string, your function connects to the Azure storage account when running locally. A new queue named **outqueue** is created in your storage account by the Functions runtime when the output binding is first used. You'll use Storage Explorer to verify that the queue was created along with the new message.

::: zone-end

### Connect Storage Explorer to your account

[!INCLUDE [functions-storage-explorer-connect.md](../../includes/functions-storage-explorer-connect.md)]

### Examine the output queue

1. In Visual Studio Code, press <kbd>F1</kbd> to open the command palette, then search for and run the command `Azure Storage: Open in Storage Explorer` and choose your storage account name. Your storage account opens in the Azure Storage Explorer.  

1. Expand the **Queues** node, and then select the queue named **outqueue**.

   The queue contains the message that the queue output binding created when you ran the HTTP-triggered function. If you invoked the function with the default `name` value of *Azure*, the queue message is *Name passed to the function: Azure*.

    :::image type="content" source="./media/functions-add-output-binding-storage-queue-vs-code/function-queue-storage-output-view-queue.png" alt-text="Screenshot of the queue message shown in Azure Storage Explorer.":::

1. Run the function again, send another request, and you see a new message in the queue.  

Now, it's time to republish the updated function app to Azure.

## Redeploy and verify the updated app

1. In Visual Studio Code, press <kbd>F1</kbd> to open the command palette. In the command palette, search for and select `Azure Functions: Deploy to function app...`.

1. Choose the function app that you created in the first article. Because you're redeploying your project to the same app, select **Deploy** to dismiss the warning about overwriting files.

1. After the deployment completes, you can again use the **Execute Function Now...** feature to trigger the function in Azure.

1. Again [view the message in the storage queue](#examine-the-output-queue) to verify that the output binding generates a new message in the queue.

## Clean up resources

In Azure, *resources* refer to function apps, functions, storage accounts, and so forth. They're grouped into *resource groups*, and you can delete everything in a group by deleting the group.

You've created resources to complete these quickstarts. You may be billed for these resources, depending on your [account status](https://azure.microsoft.com/account/) and [service pricing](https://azure.microsoft.com/pricing/). If you don't need the resources anymore, here's how to delete them:

[!INCLUDE [functions-cleanup-resources-vs-code-inner.md](../../includes/functions-cleanup-resources-vs-code-inner.md)]

## Next steps

You've updated your HTTP triggered function to write data to a Storage queue. Now you can learn more about developing Functions using Visual Studio Code:

* [Develop Azure Functions using Visual Studio Code](functions-develop-vs-code.md)

* [Azure Functions triggers and bindings](functions-triggers-bindings.md).
::: zone pivot="programming-language-csharp"  
* [Examples of complete Function projects in C#](/samples/browse/?products=azure-functions&languages=csharp).

* [Azure Functions C# developer reference](functions-dotnet-class-library.md)  
::: zone-end
::: zone pivot="programming-language-javascript"  
* [Examples of complete Function projects in JavaScript](/samples/browse/?products=azure-functions&languages=javascript).

* [Azure Functions JavaScript developer guide](functions-reference-node.md?tabs=javascript)  
::: zone-end  
::: zone pivot="programming-language-java"  
* [Examples of complete Function projects in Java](/samples/browse/?products=azure-functions&languages=java).

* [Azure Functions Java developer guide](functions-reference-java.md)  
::: zone-end  
::: zone pivot="programming-language-typescript"  
* [Examples of complete Function projects in TypeScript](/samples/browse/?products=azure-functions&languages=typescript).

* [Azure Functions TypeScript developer guide](functions-reference-node.md?tabs=typescript)  
::: zone-end  
::: zone pivot="programming-language-python"  
* [Examples of complete Function projects in Python](/samples/browse/?products=azure-functions&languages=python).

* [Azure Functions Python developer guide](functions-reference-python.md)  
::: zone-end  
::: zone pivot="programming-language-powershell"  
* [Examples of complete Function projects in PowerShell](/samples/browse/?products=azure-functions&languages=azurepowershell).

* [Azure Functions PowerShell developer guide](functions-reference-powershell.md)
::: zone-end
