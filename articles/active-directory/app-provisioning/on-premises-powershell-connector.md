---
title: Azure AD Provisioning to applications via PowerShell
description: This document describes how to configure Azure AD to provision users with external systems that offer Windows PowerShell based APIs.
services: active-directory
author: billmath
manager: amycolannino
ms.service: active-directory
ms.subservice: app-provisioning
ms.topic: how-to
ms.workload: identity
ms.date: 02/08/2022
ms.author: billmath
ms.reviewer: arvinh
---

# Provisioning users into applications using PowerShell
The following documentation provides configuration and tutorial information demonstrating how the generic PowerShell connector and the ECMA Connector Host can be used to integrate Azure AD with external systems that offer Windows PowerShell based APIs.

For additional information see [Windows PowerShell Connector technical reference](/microsoft-identity-manager/reference/microsoft-identity-manager-2016-connector-powershell)


## Prerequisites for provisioning via PowerShell

### On-premises prerequisites

The connector provides a bridge between the capabilities of the ECMA Connector Host and Windows PowerShell. Before you use the Connector, make sure you have the following on the server hosting the connector



- A Windows Server 2016 or a later version. 
- At least 3 GB of RAM, to host a provisioning agent. 
- .NET Framework 4.7.2 
- Windows PowerShell 2.0, 3.0, or 4.0
-  Connectivity to the target system hosting the PowerShell API.
- The execution policy on the server must be configured to allow the connector to run Windows PowerShell scripts. Unless the scripts the connector runs are digitally signed, configure the execution policy by running this command:  
`Set-ExecutionPolicy -ExecutionPolicy RemoteSigned`
- Deploying this connector will require one or more PowerShell scripts.  Some Microsoft products may provide scripts for use with this connector, and the support statement for those scripts would be provided by that product.  If you are developing your own scripts for use with this connector, you will need to have familiarity with the [Extensible Connectivity Management Agent API](https://msdn.microsoft.com/library/windows/desktop/hh859557.aspx) to develop and maintain those scripts.  If you are integrating with third party systems using your own scripts in a production environment, we recommend you work with the third party vendor or a deployment partner for help, guidance and support for this integration.



### Cloud requirements

 - An Azure AD tenant with Azure AD Premium P1 or Premium P2 (or EMS E3 or E5).   [!INCLUDE [active-directory-p1-license.md](../../../includes/active-directory-p1-license.md)]
 - The Hybrid Identity Administrator role for configuring the provisioning agent and the Application Administrator or Cloud Application Administrator roles for configuring provisioning in the Azure portal.
 - The Azure AD users to be provisioned to the database must already be populated with any attributes that will be required by the database schema and that are not generated by the database itself.

## Download, install, and configure the Azure AD Connect Provisioning Agent Package

If you have already downloaded the provisioning agent and configured it for another on-premises application, then continue reading in the next section.

  1.  In the Azure portal, select **Azure Active Directory**.
  2.  On the left, select **Azure AD Connect**.
  3.  On the left, select **Cloud sync**.
 
 :::image type="content" source="../../../includes/media/active-directory-cloud-sync-how-to-install/new-ux-1.png" alt-text="Screenshot of new UX screen." lightbox="../../../includes/media/active-directory-cloud-sync-how-to-install/new-ux-1.png":::

 4. On the left, select **Agent**.
 5. Select **Download on-premises agent**, and select **Accept terms & download**.

     >[!NOTE]
     >Please use different provisioning agents for on-premises application provisioning and Azure AD Connect Cloud Sync / HR-driven provisioning. All three scenarios should not be managed on the same agent. 

 6. Open the provisioning agent installer, agree to the terms of service, and select **next**.
 7. When the provisioning agent wizard opens, continue to the **Select Extension** tab and select **On-premises application provisioning** when prompted for the extension you want to enable.
 8. The provisioning agent will use the operating system's web browser to display a popup window for you to authenticate to Azure AD, and potentially also your organization's identity provider.  If you are using Internet Explorer as the browser on Windows Server, then you may need to add Microsoft web sites to your browser's trusted site list to allow JavaScript to run correctly.
 9. Provide credentials for an Azure AD administrator when you're prompted to authorize. The user is required to have the Hybrid Identity Administrator or Global Administrator role.
 10. Select **Confirm** to confirm the setting. Once installation is successful, you can select **Exit**, and also close the Provisioning Agent Package installer.

## Configure the On-premises ECMA app

 1. Sign in to the Azure portal as an administrator.
 2. Go to **Enterprise applications** and select **New application**.
 3. Search for the **On-premises ECMA app** application, give the app a name, and select **Create** to add it to your tenant.
 4. Navigate to the **Provisioning** page of your application.
 5. Select **Get started**.
 6. On the **Provisioning** page, change the mode to **Automatic**.
     ![Screenshot that shows changing the mode to Automatic.](.\media\active-directory-app-provisioning-sql\configure-7.png)</br>
 7. On the **On-Premises Connectivity** section, select the agent that you just deployed and select **Assign Agent(s)**.
 8. Keep this browser window open, as you complete the next step of configuration using the configuration wizard.





## Appendix A - InputFile.txt

## Apendix B - Schema.xml 

## Appendix C - Configuruation.xml 

```
<?xml version="1.0"?>
<Configuration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Connectors>
    <Connector>
      <ConnectorConfig>
        <Parameters>
          <Parameter>
            <Name>Server</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Domain</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>User</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password</Name>
            <Type>EncryptedString</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>true</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Impersonate Connector Account</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Load User Profile When Impersonating</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Logon Type When Impersonating</Name>
            <Type>DropDown</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Signed Scripts Only</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script Name (with extension)</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>xADSyncPSConnectorModule.psm1</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>
Set-PSDebug -Strict

function Enter-Script
{
  &lt;#
    .Synopsis
    Writes the Versbose message saying specified script execution started.
    .Description
    Writes the Versbose message saying specified script execution started.
    Also clear the $Error variable.
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject
  )

  process
  {
    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Started..."
    if ($ErrorObject)
    {
      $ErrorObject.Clear()
    }
  }
}

function Exit-Script
{
  &lt;#
    .Synopsis
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    .Description
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    Throws an exception if $Error is present
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject,
    [Parameter(Mandatory = $false)]
    [switch]
    $SuppressErrorCheck,
    [Parameter(Mandatory = $false)]
    [type]
    $ExceptionRaisedOnErrorCheck
  )

  process
  {
    if (!$SuppressErrorCheck -and $ErrorObject -and $ErrorObject.Count -ne 0)
    {
      # Take the first one otherwise you get "An error occurred while enumerating through a collection: Collection was modified; enumeration operation may not execute.."
      # Seems like a bug in Remote PSH
      $errorMessage = $ErrorObject[0] # | Out-String -ErrorAction SilentlyContinue

      if ($ExceptionRaisedOnErrorCheck -eq $null)
      {
        $ExceptionRaisedOnErrorCheck = [Microsoft.MetadirectoryServices.ExtensibleExtensionException]
      }

      $ErrorObject.Clear()

      throw $errorMessage -as $ExceptionRaisedOnErrorCheck
    }

    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Completed."
  }
}

function Get-ExtensionsDirectory
{
  &lt;#
    .Synopsis
    Gets the path of the "Extensions" folder.
    .Description
    Gets the path of the "Extensions" folder.
  #&gt;
  [CmdletBinding()]
  [OutputType([string])]
  param(
  )

  process
  {
    $scriptDir = "C:\\Program Files\\Microsoft ECMA2Host\\Service\\ECMA"

    return $scriptDir
  }
}

function ConvertFrom-SchemaXml
{
    &lt;#
    .Synopsis
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Description
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Example
    ConvertFrom-SchemaXml -SchemaXml "Schema.xml"
    #&gt;  

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateScript({ Test-Path $_ -PathType "Leaf" })]
    [string]
    $SchemaXml
  )

  process
  {
    $x = [xml](Get-Content $SchemaXml)

    $schema = [Microsoft.MetadirectoryServices.Schema]::Create()

    foreach ($t in $x.Schema.Types.SchemaType)
    {
      $lockAnchorDefinition = $true

      if ($t.LockAnchorDefinition -eq "0")
      {
        $lockAnchorDefinition = $false
      }

      $schemaType = [Microsoft.MetadirectoryServices.SchemaType]::Create($t.Name,$lockAnchorDefinition)

      if ($t.GetElementsByTagName("PossibleDNComponentsForProvisioning").Count -gt 0)
      {
        foreach ($c in $t.PossibleDNComponentsForProvisioning)
        {
          $schemaType.PossibleDNComponentsForProvisioning.Add($c)
        }
      }

      foreach ($a in $t.Attributes.SchemaAttribute)
      {
        if ($a.IsAnchor -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        elseif ($a.IsMultiValued -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        else
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
      }

      $schema.Types.Add($schemaType)
    }

    return $schema
  }
}


function Get-xADSyncPSConnectorSetting
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNull()]
    [Alias('InputObject')]
    [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]
    $ConfigurationParameters,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Global','Partition','RunStep')]
    [string]
    $Scope,
    $DefaultValue
  )
  process
  {
    try
    {
      $scopedName = '{0}_{1}' -f $Name,$Scope

      if ($ConfigurationParameters[$scopedName].Value)
      {
        return $ConfigurationParameters[$scopedName].Value
      }
      elseif ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        return $null
      }
    }
    catch [System.Collections.Generic.KeyNotFoundException]
    {
      # if they gave us a default, go ahead and return it
      if ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        throw
      }
    }
  }
}

function Get-xADSyncPSConnectorFolder
{
  [CmdletBinding()]
  [OutputType([string])]
  param(
    [Parameter(Mandatory = $true,Position = 0)]
    [ValidateSet('ManagementAgent','Extensions')]
    [string]
    $Folder
  )

  switch ($Folder)
  {
    'ManagementAgent'
    {
      return [Microsoft.MetadirectoryServices.MAUtils]::MAFolder
    }
    'Extensions'
    {
      return [Microsoft.MetadirectoryServices.Utils]::ExtensionsDirectory
    }
    default
    {
      throw "Folder '$Folder' is not supported"
    }
  }
}

#region Schema Helpers
function New-xADSyncPSConnectorSchema
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param()

  return [Microsoft.MetadirectoryServices.Schema]::Create()
}

function New-xADSyncPSConnectorSchemaType
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.SchemaType])]
  param(
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [switch]
    $LockAnchorAttributeDefinition
  )

  return [Microsoft.MetadirectoryServices.SchemaType]::Create($Name,$LockAnchorAttributeDefinition.ToBool())
}

function Add-xADSyncPSConnectorSchemaAttribute
{
  [CmdletBinding(DefaultParameterSetName = 'Singlevalued')]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.SchemaType]
    [ValidateNotNull()]
    $InputObject,
    [ValidateNotNullOrEmpty()]
    [string]
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    $Name,
    [Parameter(ParameterSetName = 'Anchor')]
    [switch]
    $Anchor,
    [Parameter(ParameterSetName = 'Multivalued')]
    [switch]
    $Multivalued,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('Binary','Boolean','Integer','Reference','String')]
    [string]
    $DataType,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('ImportOnly','ExportOnly','ImportExport')]
    [string]
    $SupportedOperation
  )

  process
  {
    switch ($PSCmdlet.ParameterSetName)
    {
      'Singlevalued'
      {
        $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
      }
      'Multivalued'
      {
        if ($Multivalued.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      'Anchor'
      {
        if ($Anchor.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      default
      {
        throw "Parameter set '$($PSCmdlet.ParameterSetName)' is not supported"
      }
    }
  }
}
#endregion

#region Partition Helpers
function New-FIMPSConnectorPartition
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetaDirectoryServices.Partition])]
  param(
    [Parameter(Mandatory = $true)]
    [guid]
    $Identifier,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  if ($PSBoundParameters.ContainsKey('DisplayName'))
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName,$DisplayName)
  }
  else
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName)
  }
}
#endregion
function New-xADSyncPSConnectorHierarchyNode
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.HierarchyNode])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  return [Microsoft.MetadirectoryServices.HierarchyNode]::Create($DistinguishedName,$DisplayName)
}
#region Hierarchy Helpers

#endregion

#region Import Helpers
function New-xADSyncPSConnectorCSEntryChange
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.CSEntryChange])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $ObjectType,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Delete','Update','Replace','None')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [Alias('DistinguishedName')]
    [string]
    $DN,
    [ValidateNotNullOrEmpty()]
    [Alias('RelativeDistinguishedName')]
    [string]
    $RDN
  )

  $csEntry = [Microsoft.MetadirectoryServices.CSEntryChange]::Create()
  $csEntry.ObjectModificationType = $ModificationType
  $csEntry.ObjectType = $ObjectType

  if ($PSBoundParameters.ContainsKey('DN'))
  {
    $csEntry.DN = $DN
  }

  if ($PSBoundParameters.ContainsKey('RDN'))
  {
    $csEntry.RDN = $RDN
  }

  Write-Output $csEntry
}

function Add-xADSyncPSConnectorCSAttribute
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.CSEntryChange]
    [ValidateNotNull()]
    $InputObject,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Update','Delete','Replace','Rename')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    $Value
  )

  process
  {
    if ($ModificationType -ne 'Rename' -and $Name -eq $null)
    {
      throw 'Name parameter is required'
    }

    if ($ModificationType -ne 'Delete' -and $Value -eq $null)
    {
      throw 'Value parameter is required'
    }

    switch ($ModificationType)
    {
      'Add'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeAdd($Name,$Value))
      }
      'Update'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeUpdate($Name,$Value))
      }
      'Delete'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeDelete($Name))
      }
      'Replace'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeReplace($Name,$Value))
      }
      'Rename'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateNewDN($Value))
      }
      default
      {
        throw "Modification type $ModificationType is not supported"
      }
    }
  }
}
#endregion

function New-GenericObject
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $TypeName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string[]]
    $TypeParameters,
    [Parameter(Mandatory = $false)]
    [object[]]
    $ConstructorParameters
  )

  $genericTypeName = $typeName + '
              `r`n' + $typeParameters.Count
  $genericType = [type]$genericTypeName

  if (!$genericType)
  {
    throw "Could not find generic type $genericTypeName"
  }

  ## Bind the type arguments to it
  $typedParameters = [Type[]]$typeParameters
  $closedType = $genericType.MakeGenericType($typedParameters)

  if (!$closedType)
  {
    throw "Could not make closed type $genericType"
  }

  ## Create the closed version of the generic type. Don't forget comma prefix
  ,[Activator]::CreateInstance($closedType,$constructorParameters)
}

Export-ModuleMember -Function * -Verbose:$false -Debug:$false</Value>
          </Parameter>
          <Parameter>
            <Name>Validation Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Schema Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>[CmdletBinding()]
param(
  [Parameter(Mandatory = $true)]
  [System.Collections.ObjectModel.KeyedCollection[string,Microsoft.MetadirectoryServices.ConfigParameter]]
  $ConfigParameters,
  [Parameter(Mandatory = $false)]
  [Alias('PSCredential')] # To fix mess-up of the parameter name in the RTM version of the PowerShell connector.
  [System.Management.Automation.PSCredential]
  $Credential,
  [Parameter(Mandatory = $false)]
  [ValidateScript({ Test-Path $_ -PathType "Container" })]
  [string]
  $ScriptDir = (Join-Path -Path $env:windir -ChildPath "TEMP") # Optional parameter for manipulation by the TestHarness script.
)

Set-StrictMode -Version "2.0"

$Global:DebugPreference = "Continue"
$Global:VerbosePreference = "Continue"

$commonModule = (Join-Path -Path ([System.Environment]::GetEnvironmentVariable('Temp', 'Machine')) -ChildPath $ConfigParameters["Common Module Script Name (with extension)"].Value)

if (!(Get-Module -Name (Get-Item $commonModule).BaseName)) { Import-Module -Name $commonModule }

Enter-Script -ScriptType "Schema" -ErrorObject $Error

function Get-ConnectorSchema
{
&lt;#
    .Synopsis
    Gets the connector space schema.
    .Description
    Gets the connector space schema defined in the "Schema.xml" file.
#&gt;

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
  )

  $extensionsDir = Get-ExtensionsDirectory
  $schemaXml = Join-Path -Path $extensionsDir -ChildPath "Schema.xml"

  $schema = ConvertFrom-SchemaXml -SchemaXml $schemaXml

  return $schema
}

Get-ConnectorSchema

Exit-Script -ScriptType "Schema" -ErrorObject $Error</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>FileName,Delimiter,Encoding</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Encrypted Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Distinguished Name Style</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Export Type</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>ObjectReplace</Value>
          </Parameter>
          <Parameter>
            <Name>Data Normalization</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Object Confirmation</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>Normal</Value>
          </Parameter>
          <Parameter>
            <Name>Use DN As Anchor (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Concurrent Operations Of Several Connectors</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Partitions (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Hierarchy (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Delta Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Full Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>No Reference Values In First Export Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Object Rename</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Delete-Add As Replace</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Password operations</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export Password In First Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Partition Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Hierarchy Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  [ValidateNotNull()]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  [ValidateNotNull()]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenImportConnectionRunStep]

  $OpenImportConnectionRunStep,

  [Microsoft.MetadirectoryServices.ImportRunStep]

  $GetImportEntriesRunStep,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict

$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

$importResults = New-Object -TypeName 'Microsoft.MetadirectoryServices.GetImportEntriesResults'

$csEntries = New-Object -TypeName 'System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChange]'

$columnsToImport = $Schema.Types[0].Attributes

Write-Verbose "Loaded $($columnsToImport.Count) attributes to import"

$importCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}

if ((Test-Path $importCsvParameters['Path'] -PathType Leaf) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($importCsvParameters['Path'])"

}

Write-Verbose "Import path: $($importCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $importCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $importCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$recordsToImport = Import-Csv @importCsvParameters

Write-Verbose "Imported $($recordsToImport.Count) records"

foreach ($record in $recordsToImport)

{

  Write-Verbose 'Starting new record'

  ##TODO: Handle a missing anchor (what exception to throw?)

  $foundValidColumns = $false

  $entrySchema = $Schema.Types[0];
  $csEntry = New-xADSyncPSConnectorCSEntryChange -ObjectType $entrySchema.Name -ModificationType Add

  foreach ($column in $columnsToImport)

  {

    $columnName = $column.Name

    Write-Verbose "Processing column $columnName"

    if ($record.$columnName)

    {

      Write-Verbose 'Found column'

      $foundValidColumns = $true

      ##TODO: Support multivalue?

      $anchorAttrName = $entrySchema.AnchorAttributes[0].Name
      $value = [string]$record.$columnName

      Write-Verbose "$columnName with value equal $value"


      if ($columnName -eq $anchorAttrName)
      {


        $csEntry.AnchorAttributes.Add([Microsoft.MetadirectoryServices.AnchorAttribute]::Create($columnName,$value))
      }


      $csEntry | Add-xADSyncPSConnectorCSAttribute -ModificationType Add -Name $columnName -Value ([Collections.IList]($record.$columnName.Split(";")))

    }

  }

  if ($foundValidColumns)

  {

    Write-Verbose 'Publishing CSEntryChange'

    $csEntries.Add($csEntry)

  }

  Write-Verbose 'Record completed'

}

##TODO: Support paging

$importResults.CSEntries = $csEntries

$importResults.MoreToImport = $false

Write-Output $importResults</Value>
          </Parameter>
          <Parameter>
            <Name>End Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>
param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenExportConnectionRunStep]

  $OpenExportConnectionRunStep,

  [System.Collections.Generic.IList[Microsoft.MetaDirectoryServices.CSEntryChange]]

  $CSEntries,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict


$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

function CreateCustomPSObject

{

  param

  (

    $PropertyNames = @()

  )

  $template = New-Object -TypeName System.Object

  foreach ($property in $PropertyNames)

  {

    $template | Add-Member -MemberType NoteProperty -Name $property -Value $null

  }

  return $template
}


function DeleteFromCsv
{
  param($CsvParameters,[string]$ColumnName,[string]$ColumnValue)

  try
  {
    Write-Verbose "Delete from CSV. File: $($CsvParameters.Path)"

    $csv = Import-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter | Where-Object $ColumnName -NE $ColumnValue

    Write-Verbose "New csv: $($csv)"

    $csv | Export-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter -NoTypeInformation
  }
  catch
  {
    Write-Error $_.ErrorDetails.Message
  }
}

$exportCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}



$csentryChangeResults = New-Object "System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChangeResult]"

if ((Test-Path ([IO.Path]::GetDirectoryName($exportCsvParameters['Path'])) -PathType Container) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($exportCsvParameters['Path'])"

}

Write-Verbose "Export path: $($exportCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $exportCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $exportCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$columnsToExport = @()

foreach ($attribute in $Schema.Types[0].Attributes)

{

  $columnsToExport += $attribute.Name

  Write-Verbose "Added attribute $($attribute.Name) to export list"

}



$csvSource = @()

Write-Verbose "Processing object $($entry.Identifier)"


foreach ($entry in $CSEntries)

{

  Write-Verbose "Processing object $($entry.Identifier). ObjectModificationType $($entry.ObjectModificationType)"

  [bool]$objectHasAttributes = $false

  $baseObject = CreateCustomPSObject -PropertyNames $columnsToExport

  if ($entry.ObjectModificationType -eq 'Replace')
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Remove the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)' before replacing it with new object"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }


  if ($entry.ObjectModificationType -ne 'Delete')

  {

    foreach ($attribute in $columnsToExport)

    {

      if (($entry.AttributeChanges.Contains($attribute)) -eq $false -and ($entry.AnchorAttributes.Contains($attribute) -eq $false))

      {

        continue

      }


      if ($entry.AnchorAttributes[$attribute].Value)

      {

        $baseObject.$attribute = $entry.AnchorAttributes[$attribute].Value

        $objectHasAttributes = $true

      }

      elseif ($entry.AttributeChanges[$attribute].ValueChanges[0].Value)

      {

        $baseObject.$attribute = ($entry.AttributeChanges[$attribute].ValueChanges | Select-Object -Expand Value) -join ";"

        $objectHasAttributes = $true

      }

    }

    if ($objectHasAttributes)

    {

      $csvSource += $baseObject

    }


  }
  else
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Delete the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)'"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }

  $csentryChangeResult = [Microsoft.MetadirectoryServices.CSEntryChangeResult]::Create($entry.Identifier,$null,"Success")
  $csentryChangeResults.Add($csentryChangeResult)

  Write-Verbose "Completed processing object $($entry.Identifier)"

}

$csvSource | Export-Csv @exportCsvParameters -NoTypeInformation -Append -Force

$closedType = [type]"Microsoft.MetadirectoryServices.PutExportEntriesResults"

return [Activator]::CreateInstance($closedType,$csentryChangeResults)</Value>
          </Parameter>
          <Parameter>
            <Name>End Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password Extension Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>End Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PowerShell script execution timeout in minutes (0 â€“ disabled)</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>FileName_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>FileName_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PageSizeFullImport</Name>
            <Type>Text</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>5000</Value>
          </Parameter>
        </Parameters>
        <RunConfigurations>
          <RunConfiguration>
            <Id>9fd4ccfc-55b6-4e3a-a9ac-ef2f451018e7</Id>
            <Name>Export</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:19.2865423-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:19.2865423-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Export</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeExport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
          <RunConfiguration>
            <Id>4587911e-9173-4324-98fd-a8e6207bae33</Id>
            <Name>FullImport</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:46.7386769-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:46.7386769-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Import</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeFullImport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
        </RunConfigurations>
        <IsExportSupported>true</IsExportSupported>
        <IsFullImportSupported>true</IsFullImportSupported>
        <IsDeltaImportSupported>false</IsDeltaImportSupported>
        <IsExportOnly>false</IsExportOnly>
      </ConnectorConfig>
      <Schema>
        <EntriesSchema>
          <EntrySchema>
            <ExternalName>User</ExternalName>
            <ObjectType>Person</ObjectType>
            <SchemaAttributes>
              <AttributeSchema>
                <Name>AzureObjectID</Name>
                <IsAnchor>true</IsAnchor>
                <IsDN>true</IsDN>
                <IsQueryAttribute>true</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>DisplayName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Email</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>EmployeeId</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>IsActive</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>Boolean</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Title</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>UserName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
            </SchemaAttributes>
            <IsDNAutogenerated>false</IsDNAutogenerated>
            <DeprovisioningModel>
              <HardDeleteStatusAttribute />
              <SoftDeleteStatusAttribute />
              <HardDelete>TreatAsHard</HardDelete>
              <SoftDelete>None</SoftDelete>
            </DeprovisioningModel>
          </EntrySchema>
        </EntriesSchema>
        <Partitions>
          <Partition>
            <Id>ba05a46c-9390-4b85-9019-a1811be08949</Id>
            <Name>default</Name>
            <DN>default</DN>
          </Partition>
        </Partitions>
        <ExportPasswordInFirstPass>False</ExportPasswordInFirstPass>
        <SupportPassword>False</SupportPassword>
      </Schema>
      <ECMAConfig>
        <ECMAFolderPath />
        <LibraryName>Microsoft.IAM.Connector.PowerShell</LibraryName>
        <AutosyncTimer>120</AutosyncTimer>
        <SecretToken>AAEAAAD/////AQAAAAAAAAAMAgAAAFRNaWNyb3NvZnQuRUNNQTJIb3N0LkVuY3J5cHRlZCwgVmVyc2lvbj0xLjEuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPW51bGwFAQAAAChNaWNyb3NvZnQuRUNNQTJIb3N0LkVuY3J5cHRlZC5EYXRhRW5jeXB0AgAAABU8RGF0YT5rX19CYWNraW5nRmllbGQVPFNhbHQ+a19fQmFja2luZ0ZpZWxkAQcCAgAAAAYDAAAAtAJBUUFBQU5DTW5kOEJGZEVSakhvQXdFL0NsK3NCQUFBQXQxMjdENDNmQTBxOGcxVFpvcXVNdlFRQUFBQUNBQUFBQUFBUVpnQUFBQUVBQUNBQUFBQVdrTzZjYWFVYk9HVDAvTEpFS1F4NStJOTM1ajJCRlN1R0xxeUsyc0JvcndBQUFBQU9nQUFBQUFJQUFDQUFBQUJPS05oUEp2S0FhYnBsN3FzdlZUUkl5UkJlNE15YmUvMWFBeURFZ2VGbUpCQUFBQUM2WHRlODM2NHQ0Qlo4U1RIK0FjdFhRQUFBQUdpWTNuQ1k4SHNTMDVHVmFyRXZTZ3JySFluODZJZjVPc051QkEyR2dFbUo0QndsZWs1M1l0amdHbXovUWlTUnBzLzloTUcyVnhqd1Q3UUFjbDdlMlA0PQkEAAAADwQAAACAAAAAAkqvVUJOAfvBBrLQGYraaCdzjJs5EOzX3cMF3G0Rgt+RTg9Xq4GTmFWdSW7auKJFH4ftf2iIBgqq2O2vRKm9RHgVU2O4q1OAQU/ixQMvNfS7CwdceNBWwo7zkrioP3tjFyweM4hzpBHhEPJ8RX3ONEFKpLoFDcgwFAfo8xEmGO4OCw==</SecretToken>
        <ProfileName>CSV</ProfileName>
        <CreationDateTime>Thursday, April 27, 2023 9:09:03 PM</CreationDateTime>
        <ModificationDateTime>Thursday, April 27, 2023 9:22:22 PM</ModificationDateTime>
        <Validated>true</Validated>
      </ECMAConfig>
    </Connector>
  </Connectors>
  <Setting>
    <Port>8585</Port>
    <Certificate>B1059D9236D99040B597C34DC736733870CBF652</Certificate>
  </Setting>
</Configuration>

```


