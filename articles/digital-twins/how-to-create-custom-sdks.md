---
# Mandatory fields.
title:  Create custom SDKs for Azure Digital Twins with AutoRest
titleSuffix: Azure Digital Twins
description: See how to generate custom SDKs, to use Azure Digital Twins with languages other than C#.
author: baanders
ms.author: baanders # Microsoft employees only
ms.date: 4/24/2020
ms.topic: how-to
ms.service: digital-twins

# Optional fields. Don't forget to remove # if you need a field.
# ms.custom: can-be-multiple-comma-separated
# ms.reviewer: MSFT-alias-of-reviewer
# manager: MSFT-alias-of-manager-or-PM-counterpart
---

# Create custom SDKs for Azure Digital Twins with AutoRest

Right now, the only published  data plane SDK for interacting with the Azure Digital Twins APIs is for .NET (C#). You can read about the .NET SDK, and the APIs in general, in [How-to: Use the Azure Digital Twins APIs and SDKs](how-to-use-apis-sdks.md). If you are working in another language, this article will show you how to generate your own SDK in the language of your choice, using AutoRest.

## Set up the SDK

To generate an SDK, you will need:
* [AutoRest](https://github.com/Azure/autorest), version 2.0.4413 (version 3 isn't currently supported)
* [Node.js](https://nodejs.org) as a pre-requisite to AutoRest
* The [Azure Digital Twins OpenAPI (Swagger) file](https://github.com/Azure/azure-rest-api-specs/blob/master/specification/digitaltwins/resource-manager/Microsoft.DigitalTwins/preview/2020-03-01-preview/digitaltwins.json)

If you have Node.js installed, you can run this command to make sure you have the right version of AutoRest installed:
```cmd/sh
npm install -g autorest@2.0.4413
```

To run AutoRest against the Azure Digital Twins Swagger file, follow these steps:
1. Copy the Azure Digital Twins Swagger file in a working directory.
2. On a command prompt, switch to that working directory.
3. Run AutoRest with the following command.

```cmd/sh
autorest --input-file=adtApiSwagger.json --csharp --output-folder=ADTApi --add-credentials --azure-arm --namespace=ADTApi
```

As a result, you will see a new folder named *ADTApi* in your working directory. The generated SDK files will have the namespace *ADTApi*, which you'll continue to use through the rest of the examples.

AutoRest supports a wide range of language code generators.

## Add the SDK to a Visual Studio project

You can include the files generated by AutoRest directly into a .NET solution. However, as you will likely need the Azure Digital Twins SDK in several separate projects (your client apps, Azure Functions apps etc.), we recommend that you build a separate project (a .NET class library) from the generated files. You can then include this class library project into your other solutions as a project reference.

This section gives instructions on how to build the SDK as a class library, which is its own project and can be included into other projects. Here are the steps:

1. Create a new Visual Studio solution for a class library
2. Use the name "ADTApi" as the project name
3. In Solutions Explorer, right-select the *ADTApi* project of the generated solution and choose *Add > Existing Item...*
4. Find the folder where you generated the SDK, and select the files at the root level
5. Press "Ok"
6. Add a folder to the project (right-select the project in Solution Explorer, and choose *Add > New Folder*)
7. Name the folder "Models"
8. Right-select the *Models* folder in Solutions Explorer and select *Add > Existing Item...*
9. Select the files in the *Models* folder of the generated SDK and press "Ok"

To build the SDK successfully, your project will need these references:
* `Microsoft.Rest.ClientRuntime`
* `Microsoft.Rest.ClientRuntime.Azure`

To add these, open *Tools > NuGet Package Manager > Manage NuGet Packages for Solution...*.

1. In the panel, make sure the *Browse* tab is selected
2. Search for *Microsoft.Rest*
3. Select the *ClientRuntime* and *ClientRuntime.Azure* packages, and add them to your solution

You can now build the project, and include it as a project reference in any Azure Digital Twins application you write.

## General guidelines for generated SDKs

This section contains general information about and guidelines for using the generated SDK.

### Synchronous and asynchronous calls

All SDK functions come in synchronous and asynchronous versions.

### Typed and untyped data

REST API calls generally return strongly-typed objects. However, because Azure Digital Twins lets users define their own custom types for twins, there is no way to pre-define static return data for many Azure Digital Twins calls. Instead, the APIs return strongly-typed wrapper types where applicable, and the custom-typed twin data is in Json.NET objects (used wherever the data type "object" appears in the API signatures). You can cast these objects appropriately in your code.

### Error handling

Whenever an error occurs in the SDK (including HTTP errors such as 404), the SDK will throw an exception. For this reason, it's important to encapsulate all API calls within try/catch blocks.

Here is a code snippet that tries to add a twin and catches any errors in this process:

```csharp
try
{
    await client.DigitalTwins.AddAsync(id, initData);
    Console.WriteLine($"Created a twin successfully: {id}");
}
catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error creating twin {id}: {e.Response.StatusCode}"); 
}
```

### Paging

AutoRest generates two types of paging patterns for the SDK:
* One for all APIs except the Query API
* One for the Query API

In the non-query paging pattern, there are two versions of each call:
* A version to make the initial call (such as `DigitalTwins.ListEdges()`)
* A version to get subsequent pages, suffixed with "Next" (such as `DigitalTwins.ListEdgesNext()`)

Here is a code snippet showing how to retrieve a paged list of outgoing relationships from Azure Digital Twins:
```csharp
try
{
    // List to hold the results in
    List<object> relList = new List<object>();
    // Enumerate the IPage object returned to get the results
    // ListAsync will throw if an error occurs
    IPage<object> relPage = await client.DigitalTwins.ListEdgesAsync(id);
    relList.AddRange(relPage);
    // If there are more pages, the NextPageLink in the page is set
    while (relPage.NextPageLink != null)
    {
        // Get more pages...
        relPage = await client.DigitalTwins.ListEdgesNextAsync(relPage.NextPageLink);
        relList.AddRange(relPage);
    }
    Console.WriteLine($"Found {relList.Count} relationships on {id}");
    // Do something with each object found
    // As relationships are custom types, they are JSON.Net types
    foreach (JObject r in relList)
    {
        string relId = r.Value<string>("$edgeId");
        string relName = r.Value<string>("$relationship");
        Console.WriteLine($"Found relationship {relId} from {id}");
    }
}
catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error retrieving relationships on {id}: {e.Response.StatusCode}");
}
```

The second pattern is only generated for the Query API. It uses a `continuationToken` explicitly.

Here is an example with this pattern:

```csharp
string query = "SELECT * FROM digitaltwins";
string conToken = null; // continuation token from the query
int page = 0;
try
{
    // Repeat the query while there are pages
    do
    {
        QuerySpecification spec = new QuerySpecification(query, conToken);
        QueryResult qr = await client.Query.QueryTwinsAsync(spec);
        page++;
        Console.WriteLine($"== Query results page {page}:");
        if (qr.Items != null)
        {
            // Query returns are JObjects
            foreach(JObject o in qr.Items)
            {
                string twinId = o.Value<string>("$dtId");
                Console.WriteLine($"  Found {twinId}");
            }
        }
        Console.WriteLine($"== End query results page {page}");
        conToken = qr.ContinuationToken;
    } while (conToken != null);
} catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error in twin query: ${e.Response.StatusCode}");
}
```

## Next steps

Walk through the steps to create a client app where you can use your SDK:
* [Tutorial: Code a client app](tutorial-code.md)