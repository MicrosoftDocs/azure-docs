<properties 
   pageTitle="todo-service-with-web-api"
   description="This tutorial goes into details on how to create a Microsoft Azure Service Fabric application that provides a todo service using Web API"
   services="service-fabric" 
   documentationCenter=".net" 
   authors="zbrad" 
   manager="mike.andrews" 
   editor="vturcek" />

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="multiple" 
   ms.date="04/13/2015"
   ms.author="brad.merrill"/>

# Implement a Todo service with Web API

>**NOTE:** The official name of the service is Microsoft Azure Service Fabric, or Service Fabric in short. However, the tools and libraries haven't been refreshed to use this new name yet. In the following text and screen shots you'll see reference to Windows Fabric, which is the internal code name.

This tutorial walks you through the steps of creating a stateful service that manages a to-do list. The service uses Service Fabric's reliable queue to save to-do items. And it uses ASP.NET Web API to provide a REST interface with add, remove and peek operations. It's recommend that you go through the [Tutorial: Getting Started with Service Fabric Web API Service (HelloWorldWebAPI)](Tutorials/HelloWorldWebAPI/Tutorial.md) before you start with this tutorial.   

Tutorial segments

- [Create New Fabric Stateful Service Project](#create-new-fabric-stateful-service-project)
- [Add WebApiListener](#add-webapilistener)
- [Create TodoModels](#create-todo-models)
- [Create TodoController](#create-todocontroller)
- [Modify Manifests](#modify-manifests)
- [Test locally](#test-locally)

## Create New Fabric Stateful Service Project

1. Launch Visual Studio 2015 CTP 6 as **Administrator**, and create a new **Stateful Service** Project named **Todo**.
![][4] 
  <br/>You will see 2 projects in the created solution:<br/>
![][5]
  The first is the service project **Todo**, which contains the actual service implementation. The second project is the application project **TodoApplication**, which contains the application manifest and a number of PowerShell scripts that help you to deploy your application.

1. Go to the NuGet package console (Tools->NuGet Package Manager->Package Manager Console) and enter the following command to add the Web API package:<br/>
```posh
Install-Package Microsoft.AspNet.WebApi.OwinSelfHost
```

1. Extend the events provided by the Visual Studio project template with a few more:
```c#
    [Event(4, Level = EventLevel.Informational, Message = "{0}")]
    public void Info(string message)
    {
        WriteEvent(4, message);
    }

    [Event(5, Level = EventLevel.Warning, Message = "{0}")]
    public void Warn(string message)
    {
        WriteEvent(5, message);
    }

    [Event(6, Level = EventLevel.Error, Message = "{0}")]
    public void Error(string message)
    {
        WriteEvent(6, message);
    }
```
  These extra events will allow us to see error, warning, and information events generated by our service within the Visual Studio Diagnostic Events Viewer.

1. Open the **Service.cs** file in the **Todo** project and replace the existing usings with:
```c#
using System.Threading;
using System.Threading.Tasks;
using Microsoft.ServiceFabric.Services;
```
1. Replace the **RunAsync** implementation with the following code:
```c#
    protected override async Task RunAsync(CancellationToken cancellationToken)
    {
        await base.RunAsync(cancellationToken);
    }
```

1. Override the **CreateCommunicationListener** method to return a Web API listener, which we'll implement in the next section:
```c#
    protected override ICommunicationListener CreateCommunicationListener()
    {
        return new WebApiListener(this.StateManager);
    }
```
8. Save changes.

## Add WebApiListener

To simplify the tutorial, we have created a _WebApiListener_ that utilizes the _IReliableObjectStateManager_ interface, and will create Web Api conrollers that have a matching constructor, passing in the supplied interface.  For details of how this works, please see the [Create a Communication Listener using Web API Tutorial](service-fabric-get-started-communication-listener-with-web-api.md).

For now, let's add the supplied WebApiListener:
1. Right-Click **Todo** project
2. Select add existing file
3. Browse to [WebApiListener.cs][13]
4. click OK

## Create Todo Models

Models describe our messages received and sent.   For **Todo** we have defined messages for:
- TodoResult
    - contains the boolean result of an operation 
- TodoValue
    - contains a boolean result and a value of an operation
- TodoData
    - contains a value provided as a request
- TodoError
    - contains a boolean result and an error message

1. Add new class **TodoModels**
1. Replace contents with:
```c#
    namespace Todo
    {
        public sealed class TodoData
        {
        public string value { get; set; }
        }
    
        public class TodoResult
        {
        public bool result { get; set; }
    
        public TodoResult() { }
    
        public TodoResult(bool r)
        {
            this.result = r;
        }
        }
    
        public sealed class TodoError : TodoResult
        {
        public string error { get; set; }
    
        public TodoError() { }
    
        public TodoError(string message) : base(false)
        {
            this.error = message;
        }
        }
    
        public sealed class TodoValue : TodoResult
        {
        public string value { get; set; }
    
        public TodoValue() { }
    
        public TodoValue(string v) : base(true)
        {
            this.value = v;
        }
        }
    }
```
1. save the file

## Create TodoController

We can now implement our **TodoController** to receive requests via Web API.  In implementing our controller, we will make use of the _IHttpActionResult_ interface to enable our controller for asynchronous use.

1. Add new class **TodoController**

1. Replace existing usings with:
```c#
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Web.Http;
using Microsoft.ServiceFabric.Data;
using Microsoft.ServiceFabric.Data.Collections;
```

1. Within the **Todo** namespace, and a private class:
```c#
    class HttpAction : IHttpActionResult
    {
        Func<Task<HttpResponseMessage>> func = null;
        public HttpAction(Func<Task<HttpResponseMessage>> func) { this.func = func; }
        Task<HttpResponseMessage> IHttpActionResult.ExecuteAsync(CancellationToken cancellationToken) { return func(); }
    }
```

  This helper class will allow us to use _async_ operations within the controller.

1. Modify the _TodoController_ class definition to inherit from _ApiController_:
```c#
    public sealed class TodoController : ApiController
```

1. Add some instance fields for our controller methods:
```c#
    TodoData data = null;
    IReliableObjectStateManager manager = null;
```

1. Add a constructor that accepts an _IReliableObjectStateManager_ instance and stores it for method use:
```c#
    public TodoController(IReliableObjectStateManager s)
    {
        this.manager = s;
    }
```

1. Now add the helper method to get our "Todo" queue:
```c#
async Task<IReliableQueue<string>> GetQueueAsync()
{
    return await manager.GetOrAddAsync<IReliableQueue<string>>("todo");
}
```

1. Now let's implement the "add" method:
```c#
    [HttpPost, Route("add")]
    public IHttpActionResult Add([FromBody] TodoData data)
    {
        this.data = data;
        return new HttpAction(this.AddOperation);
    }
```
  So far we have only received the message, and saved away any incoming data.  But we then create a new _IHttpActionResult_ instance which will call our specified operation method, for asynchronous completion.

1. Now we can perform the actual "add" operation with the provided _IReliableObjectStateManager_ information, and the provided incoming "data" instance.
```c#
    async Task<HttpResponseMessage> AddOperation()
    {
        if (data == null || data.value == null)
          return this.Request.CreateResponse(new TodoError("no todo value supplied"));
        var queue = await GetQueueAsync();
        using (var tx = manager.CreateTransaction())
        {
            await queue.EnqueueAsync(tx, data.value);
            await tx.CommitAsync();
        }
        return this.Request.CreateResponse(new TodoResult(true));
    }
```
  Steps within the operation:
  1. Verify that the data was passed in correctly
  2. Get the instance of the _IReliableQueue_ that we are using
  3. Create a new transaction scope
  4. Add (Enqueue) the new item
  5. Commit the transaction
  6. Return the successful result
<br>
1. Now add the Remove method and Remove operation:
```c#
    [HttpGet, Route("remove")]
    public IHttpActionResult Remove() { return new HttpAction(this.RemoveOperation); }

    async Task<HttpResponseMessage> RemoveOperation()
    {
        var queue = await GetQueueAsync();
        string value = null;
        using (var tx = manager.CreateTransaction())
        {
            var cond = await queue.TryDequeueAsync(tx);
            if (cond.HasValue)
                value = cond.Value;
            await tx.CommitAsync();
        }

        if (value == null)
            return this.Request.CreateResponse(new TodoResult(false));
        return this.Request.CreateResponse(new TodoValue(value));
    }
```
1. Now add the Peek method and Peek Operation:
```c#
    [HttpGet, Route("peek")]
    public IHttpActionResult Peek() { return new HttpAction(this.PeekOperation); }

    async Task<HttpResponseMessage> PeekOperation()
    {
        var queue = await GetQueueAsync();
        string value = null;
        using (var tx = manager.CreateTransaction())
        {
            var cond = await queue.TryPeekAsync(tx);
            if (cond.HasValue)
                value = cond.Value;
            await tx.CommitAsync();
        }

        if (value == null)
            return this.Request.CreateResponse(new TodoResult(false));
        return this.Request.CreateResponse(new TodoValue(value));
    }
```
1. Save **TodoController.cs**.

## Modify Manifests

1. Open the **PackageRoot\ServiceManifest.xml** file in the **Todo** project.
2. Modify the **Endpoint** resource definition to read:
```xml
    <Endpoint Name="ServiceEndpoint" Protocol="http" Type="Input" />
```
3. Open the **AssemblyManifest.xml** file in the **TodoApplication** project.
4. After the **DefaultServices** section, replace the current:
```xml
    <Principals/>
    
    section with:

    <Principals>
        <Users>
        <User Name="PortUser" AccountType="NetworkService" />
        </Users>
    </Principals>
    <Policies>
        <DefaultRunAsPolicy UserRef="PortUser" />
    </Policies>
```
  >**NOTE**: this requirement is a temporary workaround and will be fixed in an upcoming drop.

## Test locally

1. ![][2] If you haven't done so, you need to launch a local cluster first. Launch **Windows PowerShell** as **administrator** and execute the **DevClusterSetup.ps1** script under the **_DropLocation_\ClusterSetup\Local** folder.

    >**NOTE**: Your local cluster might be already running, in which case the script will fail with many errors. If you want to clean up the local cluster, run the **CleanCluster.ps1** script under the same folder.

1. You can now build and deploy your service. Press **F5**, and your service will be started. Once the service is running, you can see its output on the **Output** window of Visual Studio.
![][3]

1. You can now send data to the service, and receive a response, following the PowerShell script:
```posh
$app = Get-ServiceFabricApplication -ApplicationName 'fabric:/TodoApplication'
$service = $app | Get-ServiceFabricService
$partition = $service | Get-ServiceFabricPartition
$replicas = $partition | Get-ServiceFabricReplica
$primary = $replicas | ? { $_.ReplicaRole -eq 'Primary' }
$address = $primary.ReplicaAddress
$item = @{ value = "foo" };
$argsAdd = @{
    Uri = "$address/add";
    Body = ConvertTo-Json $item;
    Method = "Post";
    ContentType = "application/json";
    }
Invoke-RestMethod @args 
```
1. To peek at the item that was just added:
```posh
    Invoke-RestMethod "$address/peek"
```
1. To remove the item that was just added:
```posh
    Invoke-RestMethod "$address/remove"
```
1. To peek at the next item (that doesn't exist):
```posh
    Invoke-RestMethod "$address/peek"
```
1. The outputs of the above commands look like the following:
![][7]
1. Stop the program.

    >**NOTE**: To debug locally, set break points at the lines of interest. 

## Conclusion

In this tutorial, you created a stateful service with reliable collections, and tested it locally.

<!--image references-->

[1]: ./media/service-fabric-get-started-todo-service-with-web-api/add-json.png
[2]: ./media/service-fabric-get-started-todo-service-with-web-api/change.png
[3]: ./media/service-fabric-get-started-todo-service-with-web-api/diag-events.png
[4]: ./media/service-fabric-get-started-todo-service-with-web-api/new-project.png
[5]: ./media/service-fabric-get-started-todo-service-with-web-api/new-sln.png
[6]: ./media/service-fabric-get-started-todo-service-with-web-api/psh-test.png
[7]: ./media/service-fabric-get-started-todo-service-with-web-api/response.png
[8]: ./media/service-fabric-get-started-todo-service-with-web-api/warn.png
[9]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-add.png
[10]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-install.png
[11]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-options.png
[12]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-setup.png
[13]: ./media/service-fabric-get-started-todo-service-with-web-api/file-listener.cs.txt
