---
title: 'Tutorial: Use Web PubSub for Socket.IO with Azure Function in Serverless Mode'
description: In this tutorial, you learn how to use Web PubSub for Socket.IO with Azure Function in Serverless Mode.
keywords: Socket.IO, serverless, azure function, Socket.IO on Azure, multi-node Socket.IO, scaling Socket.IO, socketio, azure socketio
author: zackliu
ms.author: chenyl
ms.date: 09/01/2024
ms.service: azure-web-pubsub
ms.topic: tutorial
---

# Tutorial: Build chat app with Azure Function in Serverless Mode (Preview)

This tutorial walks you through how to create a Web PubSub for Socket.IO service in Serverless Mode and build a chat app integrating with Azure Function.

Find full code samples that are used in this tutorial:

- [Socket.IO Serverless Sample](https://github.com/Azure/azure-webpubsub/tree/main/sdk/webpubsub-socketio-extension/examples/chat-serverless-javascript)

> [!IMPORTANT]
> Default Mode needs a persistent server, you cannot integration Web PubSub for Socket.IO in default mode with Azure Function.

## Prerequisites

> [!div class="checklist"]
> * An Azure account with an active subscription. If you don't have one, you can [create a free account](https://azure.microsoft.com/free/). 
> * [Azure Function core tool](../azure-functions/functions-run-local.md)
> * Some familiarity with the Socket.IO library.

## Create a Web PubSub for Socket.IO resource in Serverless Mode

To create a Web PubSub for Socket.IO, you can use the following [Azure CLI](/cli/azure/install-azure-cli) command:

```azcli
az webpubsub create -g <resource-group> -n <resource-name>--kind socketio --service-mode serverless --sku Premium_P1
```

## Create an Azure Function project locally

You should follow the steps to initiate a local Azure Function project.

1. Follow to step to install the latest [Azure Function core tool](../azure-functions/functions-run-local.md#install-the-azure-functions-core-tools)

1. In the terminal window or from a command prompt, run the following command to create a project in the `SocketIOProject` folder:

    ```bash
    func init SocketIOProject --worker-runtime javascript --model V4
    ```

    This command creates a JavaScript project. And enter the folder `SocketIOProject` to run the following commands.

1. Currently, the Function Bundle doesn't include Socket.IO Function Binding, so you need to manually add the package.

    1. To eliminate the function bundle reference, edit the host.json file and remove the following lines.

        ```json
        "extensionBundle": {
            "id": "Microsoft.Azure.Functions.ExtensionBundle",
            "version": "[4.*, 5.0.0)"
        }
        ```

    1. Run the command:

        ```bash
        func extensions install -p Microsoft.Azure.WebJobs.Extensions.WebPubSubForSocketIO -v 1.0.0-beta.4
        ```

1. Create a function for negotiation. The negotiation function used for generating endpoints and tokens for client to access the service.

    ```bash
    func new --template "Http Trigger" --name negotiate
    ```

    Open the file in `src/functions/negotiate.js` and replace with the following code:

    ```js
    const { app, input } = require('@azure/functions');

    const socketIONegotiate = input.generic({
        type: 'socketionegotiation',
        direction: 'in',
        name: 'result',
        hub: 'hub'
    });

    async function negotiate(request, context) {
        let result = context.extraInputs.get(socketIONegotiate);
        return { jsonBody: result };
    };

    // Negotiation
    app.http('negotiate', {
        methods: ['GET', 'POST'],
        authLevel: 'anonymous',
        extraInputs: [socketIONegotiate],
        handler: negotiate
    });
    ```

    This step creates a function `negotiate` with Http Trigger and `SocketIONegotiation` output binding, which means you can use an Http call to trigger the function and return a negotiation result that generated by `SocketIONegotiation` binding.

1. Create a function for handing messages.

    ```bash
    func new --template "Http Trigger" --name message
    ```

    Open the file `src/functions/message.js` and replace with the following code:

    ```js
    const { app, output, trigger } = require('@azure/functions');

    const socketio = output.generic({
    type: 'socketio',
    hub: 'hub',
    })

    async function chat(request, context) {
        context.extraOutputs.set(socketio, {
        actionName: 'sendToNamespace',
        namespace: '/',
        eventName: 'new message',
        parameters: [
            context.triggerMetadata.socketId,
            context.triggerMetadata.message
        ],
        });
    }

    // Trigger for new message
    app.generic('chat', {
        trigger: trigger.generic({
            type: 'socketiotrigger',
            hub: 'hub',
            eventName: 'chat',
            parameterNames: ['message'],
        }),
        extraOutputs: [socketio],
        handler: chat
    });
    ```

    This uses `SocketIOTrigger` to get triggered by a Socket.IO client message and use `SocketIO` binding to broadcast messages to namespace.

1. Create a function to return an index html for visiting.

    1. Create a folder `public` under `src/`.

    1. Create an html file `index.html` with the following content.

        ```html
        <html>

        <body>
        <h1>Socket.IO Serverless Sample</h1>
        <div id="chatPage" class="chat-container">
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message here...">
                <button onclick="sendMessage()">Send</button>
            </div>
            <div id="chatMessages" class="chat-messages"></div>
        </div>
        <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
        <script>
            function appendMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.innerText = message;
            chatMessages.appendChild(messageElement);
            hatMessages.scrollTop = chatMessages.scrollHeight;
            }

            function sendMessage() {
            const message = document.getElementById('chatInput').value;
            if (message) {
                document.getElementById('chatInput').value = '';
                socket.emit('chat', message);
            }
            }

            async function initializeSocket() {
            const negotiateResponse = await fetch(`/api/negotiate`);
            if (!negotiateResponse.ok) {
                console.log("Failed to negotiate, status code =", negotiateResponse.status);
                return;
            }
            const negotiateJson = await negotiateResponse.json();
            socket = io(negotiateJson.endpoint, {
                path: negotiateJson.path,
                query: { access_token: negotiateJson.token }
            });

            socket.on('new message', (socketId, message) => {
                appendMessage(`${socketId.substring(0,5)}: ${message}`);
            })
            }

            initializeSocket();
        </script>
        </body>

        </html>
        ```

    1. To return the HTML page, create a function and copy codes:

        ```bash
        func new --template "Http Trigger" --name index
        ```

    1. Open the file `src/functions/index.js` and replace with the following code:

        ```js
        const { app } = require('@azure/functions');

        const fs = require('fs').promises;
        const path = require('path')

        async function index(request, context) {
            try {
                context.log(`Http function processed request for url "${request.url}"`);

                const filePath = path.join(__dirname,'../public/index.html');
                const html = await fs.readFile(filePath);
                return {
                    body: html,
                    headers: {
                        'Content-Type': 'text/html'
                    }
                };
            } catch (error) {
                context.log(error);
                return {
                    status: 500,
                    jsonBody: error
                }
            }
        };

        app.http('index', {
            methods: ['GET', 'POST'],
            authLevel: 'anonymous',
            handler: index
        });

        ```

## How to run the App locally

After code is prepared, following the instructions to run the sample.

### Set up Azure Storage for Azure Function

Azure Functions requires a storage account to work even running in local. Choose either of the two following options:

* Run the free [Azurite emulator](../storage/common/storage-use-azurite.md).
* Use the Azure Storage service. This may incur costs if you continue to use it.

#### [Local emulation](#tab/storage-azurite) 

1. Install the Azurite

```bash
npm install -g azurite
```

1. Start the Azurite storage emulator:

```bash
azurite -l azurite -d azurite\debug.log
```

1. Make sure the `AzureWebJobsStorage` in *local.settings.json* set to `UseDevelopmentStorage=true`.

#### [Azure Blob Storage](#tab/azure-blob-storage) 

Update the project to use the Azure Blob Storage connection string.

```bash
func settings add AzureWebJobsStorage "<storage-connection-string>"
```

---

### Set up configuration of Web PubSub for Socket.IO

1. Add connection string to the Function APP:

```bash
func settings add WebPubSubForSocketIOConnectionString "<connection string>"
```

1. Add hub settings to the Web PubSub for Socket.IO

```bash
az webpubsub hub create -n <resource name> -g <resource group> --hub-name hub --event-handler url-template="tunnel:///runtime/webhooks/socketio" user-event-pattern="*"
```

The connection string can be obtained by the Azure CLI command

```azcli
az webpubsub key show -g <resource group> -n <resource name>
```

The output contains `primaryConnectionString` and `secondaryConnectionString`, and either is available.

### Set up tunnel 

In serverless mode, the service uses webhooks to trigger the function. When you try to run the app locally, a crucial problem is let the service be able to access your local function endpoint.

An easiest way to achieve it's to use [Tunnel Tool](../azure-web-pubsub/howto-web-pubsub-tunnel-tool.md)

1. Install Tunnel Tool:

    ```bash
    npm install -g @azure/web-pubsub-tunnel-tool
    ```

1. Run the tunnel

    ```bash
    awps-tunnel run --hub hub --connection "<connection string>" --upstream http://127.0.0.1:7071
    ```

    The `--upstream` is the url that local Azure Function exposes. The port may be different and you can check the output when starting the function in the next step.

### Run Sample App

After tunnel tool is running, you can run the Function App locally:

```bash
func start
```

And visit the webpage at `http://localhost:7071/api/index`. 

:::image type="content" source="./media/socket-io-serverless-tutorial/chat-sample.png" alt-text="Screenshot of the serverless chat app.":::

## Next steps
Next, you can try to use Bicep to deploy the app online with identity-based authentication:

> [!div class="nextstepaction"]
> [Quickstart: Build chat app with Azure Function in Socket.IO Serverless Mode](./socket-io-serverless-quickstart.md)
