---
# Mandatory fields.
title: Use the Azure Digital Twins APIs
titleSuffix: Azure Digital Twins
description: Understand details of the Azure Digital Twins API surface.
author: baanders
ms.author: baanders # Microsoft employees only
ms.date: 3/12/2020
ms.topic: how-to
ms.service: digital-twins

# Optional fields. Don't forget to remove # if you need a field.
# ms.custom: can-be-multiple-comma-separated
# ms.reviewer: MSFT-alias-of-reviewer
# manager: MSFT-alias-of-manager-or-PM-counterpart
---

# Developer overview of Azure Digital Twins APIs

This article gives a brief overview of the API surface of Azure Digital Twins, and how to use it with an existing Azure Digital Twins instance. 

> [!NOTE]
> * To learn how to create an Azure Digital Twins instance, please see [Create an Azure Digital Twins instance](how-to-set-up-instance.md).
> * To learn how to authenticate and connect to an instance, please see [Authenticate against Azure Digital Twins](how-to-authenticate.md).

The Azure Digital Twins API surface can be broadly divided into the following categories: 

* **DigitalTwinsModels** - The DigitalTwinsModels category contains APIs to manage the [models](concepts-models.md) in an Azure Digital Twins instance. Management activities include upload, validation, and retrieval of models authored in DTDL.
* **DigitalTwins** - The DigitalTwins category contains the APIs that let developers create, modify, and delete [digital twins](concepts-twins-graph.md) and their relationships in an Azure Digital Twins instance.
* **Query** - The Query category lets developers [find sets of digital twins in the twin graph](how-to-query-graph.md) across relationships.
* **EventRoutes** - The EventRoutes category contains APIs to [route data](concepts-route-events.md), through the system and to downstream services.

## Generate Azure Digital Twins SDKs (preview)

During this preview release, Azure Digital Twins does not ship with an SDK. You can either use the REST APIs directly, or you can generate an SDK using AutoRest.

To generate an SDK, you will need:
* [AutoRest](https://github.com/Azure/autorest), version 2.0.4413
* [Node.js](https://nodejs.org) as a pre-requisite to AutoRest
* The [Azure Digital Twins API definitions](https://dev.azure.com/ADT-PM-STAGING/PrivatePreviewStage/_git/PrivatePreviewStage?path=%2FOpenApiSpec%2Fdigitaltwins.json) OpenAPI (Swagger) file

If you have Node.js installed, you can run this command to make sure you have the right version of AutoRest installed:
```bash
npm install -g autorest@2.0.4413
```

To run AutoRest against the Azure Digital Twins Swagger file, follow these steps:
1. Copy the Azure Digital Twins Swagger file in a working directory.
2. On a command prompt, switch to that working directory.
3. Run AutoRest with the following command.

```bash
autorest --input-file=adtApiSwagger.json --csharp --output-folder=ADTApi --add-credentials --azure-arm --namespace=ADTApi
```

As a result, you will see a new folder named *ADTApi* in your working directory. The generated SDK files will have the namespace *ADTApi*, which you'll continue to use through the rest of the examples.

AutoRest supports a wide range of language code generators. During preview, SDK generation is only guaranteed with C# and Typescript.

## Add the SDK to a Visual Studio Project

You can include the C# files generated by AutoRest directly into a .NET solution. However, as you will likely need the Azure Digital Twins SDK in several separate projects (your client apps, Azure Functions apps etc.), we recommend that you build a separate project (a .NET class library) from the generated files. You can then include this class library project into your other solutions as a project reference.

This section gives instructions on how to build the SDK as a C# class library, which is its own project and can be included into other projects. Here are the steps:

1. Create a new Visual Studio solution for a C# class library
2. Use the name "ADTApi" as the project name
3. In Solutions Explorer, right-select the *ADTApi* project of the generated solution and choose *Add > Existing Item...*
4. Find the folder where you generated the SDK, and select the C# files at the root level
5. Press "Ok"
6. Add a folder to the project (right-select the project in Solution Explorer, and choose *Add > New Folder*)
7. Name the folder "Models"
8. Right-select the *Models* folder in Solutions Explorer and select *Add > Existing Item...*
9. Select the C# files in the *Models* folder of the generated SDK and press "Ok"

To build the SDK successfully, your project will need these references:
* Microsoft.Rest.ClientRuntime 
* Microsoft.Rest.ClientRuntime.Azure

To add these, open *Tools > NuGet Package Manager > Manage NuGet Packages for Solution...*.

1. In the panel, make sure the *Browse* tab is selected
2. Search for "Microsoft.Rest"
3. Select the *ClientRuntime* and *ClientRuntime.Azure* packages, and add them to your solution

You can now build the project, and include it as a project reference in any Azure Digital Twins application you write.

## General usage guidelines

This section contains general information about and guidelines for using the generated C# SDK.

### Synchronous and asynchronous calls

All SDK functions come in synchronous and asynchronous versions.

### Typed and untyped data

REST API calls generally return strongly-typed objects. However, because Azure Digital Twins lets users define their own custom types for twins, there is no way to pre-define static return data for many Azure Digital Twins calls. Instead, the APIs return strongly-typed wrapper types where applicable, and the custom-typed twin data is in Json.NET objects (used wherever the data type "object" appears in the API signatures). You can cast these objects appropriately in your code.

### Error handling

Whenever an error occurs in the SDK (including HTTP errors such as 404), the SDK will throw an exception. As a result, it is important to encapsulate all API calls within try/catch blocks.

Here is a code snippet that tries to add a twin and catches any errors in this process:

```csharp
try
{
    await client.DigitalTwins.AddAsync(id, initData);
    Console.WriteLine($"Created a twin successfully: {id}");
}
catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error creating twin {id}: {e.Response.StatusCode}"); 
}
```

### Paging

AutoRest generates two types of paging patterns for the SDK:
* One for all APIs except the Query API
* One for the Query API

In the non-query paging pattern, there are two versions of each call:
* A version to make the initial call (such as `DigitalTwins.ListEdges()`)
* A version to get subsequent pages, suffixed with "Next" (such as `DigitalTwins.ListEdgesNext()`)

Here is a code snippet showing how to retrieve a paged list of outgoing relationships from Azure Digital Twins:
```csharp
try
{
    // List to hold the results in
    List<object> relList = new List<object>();
    // Enumerate the IPage object returned to get the results
    // ListAsync will throw if an error occurs
    IPage<object> relPage = await client.DigitalTwins.ListEdgesAsync(id);
    relList.AddRange(relPage);
    // If there are more pages, the NextPageLink in the page is set
    while (relPage.NextPageLink != null)
    {
        // Get more pages...
        relPage = await client.DigitalTwins.ListEdgesNextAsync(relPage.NextPageLink);
        relList.AddRange(relPage);
    }
    Console.WriteLine($"Found {relList.Count} relationships on {id}");
    // Do something with each object found
    // As relationships are custom types, they are JSON.Net types
    foreach (JObject r in relList)
    {
        string relId = r.Value<string>("$edgeId");
        string relName = r.Value<string>("$relationship");
        Console.WriteLine($"Found relationship {relId} from {id}");
    }
}
catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error retrieving relationships on {id}: {e.Response.StatusCode}");
}
```

The second pattern is only generated for the Query API. It uses a `continuationToken` explicitly.

Here is an example with this pattern:

```csharp
string query = "SELECT * FROM digitaltwins";
string conToken = null; // continuation token from the query
int page = 0;
try
{
    // Repeat the query while there are pages
    do
    {
        QuerySpecification spec = new QuerySpecification(query, conToken);
        QueryResult qr = await client.Query.QueryTwinsAsync(spec);
        page++;
        Console.WriteLine($"== Query results page {page}:");
        if (qr.Items != null)
        {
            // Query returns are JObjects
            foreach(JObject o in qr.Items)
            {
                string twinId = o.Value<string>("$dtId");
                Console.WriteLine($"  Found {twinId}");
            }
        }
        Console.WriteLine($"== End query results page {page}");
        conToken = qr.ContinuationToken;
    } while (conToken != null);
} catch (ErrorResponseException e)
{
    Console.WriteLine($"*** Error in twin query: ${e.Response.StatusCode}");
}
```

## Next steps

See how to use the APIs to manage models, digital twins, and twin graphs:
* [Manage a twin type model](how-to-manage-model.md)
* [Manage an individual digital twin](how-to-manage-twin.md)
* [Manage a twin graph](how-to-manage-graph.md)